---
title: セマンティック バージョニング 2.0.0
language: ja
---

# セマンティック バージョニング 2.0.0

## 概要

バージョンナンバーは、メジャー.マイナー.パッチとし、バージョンを上げるには、

1. API の変更に互換性のない場合はメジャーバージョンを、
2. 後方互換性があり機能性を追加した場合はマイナーバージョンを、
3. 後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。

プレリリースやビルドナンバーなどのラベルに関しては、メジャー.マイナー.パッチの形
式を拡張する形で利用することができます。

## 導入

ソフトウェア・マネージメントの世界には、『依存性地獄』と呼ばれる恐ろしいものがあ
ります。あなたのシステムが大きく成長すればするほど、さまざまなパッケージを組み込
めば組み込むほど、自分が地獄の底にいることにいつか気づくでしょう。

多くの依存性を有しているシステムにとって、新しいバージョンがリリースされることは
悪夢でしかありません。厳密に依存関係を指定してしまうと、システムはバージョン・ロ
ック（すべての依存パッケージを新しくしない限り、アップグレードできないこと）の危
機にさらされてしまいます。反対に、依存指定を緩く管理しすぎると、バージョンが複雑
に絡まり合い、痛い目にあうことは避けられないでしょう（合理性よりも将来のバージョ
ンとの互換性を気にすることになる）。依存性地獄とは、あなたのプロジェクトでバージ
ョン・ロックまたはバージョン混乱に陥ることで、プロジェクトに支障をきたすことを指
します。

この問題の解決策として、私はシンプルなルールセットとバージョン・ナンバーをどのよ
うに割り当て、バージョンを上げていくのかについての要件を提案します。これらのルー
ルは既存のクローズドまたはオープンソースプロジェクトで普及している一般的な（必ず
しもそうであるとは限りませんが）プラクティスをもとに作られています。このシステム
を利用するために、まずはパブリックな API を宣言する必要があります。これはドキュ
メントに記載しても、コード自体で表現しても構いません。とにかく、API が明確かつ正
確であることは非常に重要です。パブリックな API を宣言したら、それを変更する際に
はルールに従ってバージョン番号を上げなければなりません。つまり、X.Y.Z（メジャー.
マイナー.パッチ）のバージョン形式を遵守しなければなりません。API に影響を及ぼさ
ないバグ修正はパッチバージョンを、後方互換性を保ちつつ API を変更・追加した場合
はマイナーバージョンを、後方互換性のない API の変更はメジャーバージョンを上げま
す。

私はこのシステムを『セマンティック バージョニング』と呼び、このスキームに従えば
、あるバージョンのコードが次のバージョンへの変更された際に何が変更されたのかユー
ザーに伝えることができます。

## セマンティック バージョニング仕様書 (SemVer)

この文書における各キーワード「しなければなりません（MUST）」、「してはなりません
（MUST NOT）」、「要求されている（REQUIRED）」、「することになる(SHALL)」、「す
ることはない（SHALL NOT）」、「する必要がある（SHOULD）」、「しないほうがよい
（SHOULD NOT）」、「推奨される（RECOMMENDED）」、「してもよい（MAY）」、「選択で
きる（OPTIONAL）」は、[RFC 2119](http://tools.ietf.org/html/rfc2119)に記載されて
いる内容に従い解釈してください。

1. セマンティック バージョニングを適用するソフトウェアはパブリック API を宣言し
   なければなりません（MUST）。この API はコード自体で表現されているかもしれませ
   んし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れが
   ないようにするべきです。

2. 通常のバージョンナンバーは、X.Y.Z の形式にしなければなりません（MUST）。この
   とき X、Y、Z は負の整数であってはならず、各数値の先頭にゼロを配置してはなりま
   せん（MUST NOT）。X はメジャーバージョン、Y はマイナーバージョン、Z はパッチ
   バージョンを表します。各バージョンは数値的にバージョンアップしなければなりま
   せん（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。

3. 一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは
   修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリー
   スしなければなりません（MUST）。

4. メジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変
   更も起こりうります。この時のパブリック API は安定していると考えるべきではあり
   ません。

5. バージョン 1.0.0 でパブリック API を定義します。このリリース後のバージョンナ
   ンバーの上げ方に関しては、パブリック API がどのくらい変更されるのかによって決
   まります。

6. パッチバージョン Z （x.y.Z `|` x > 0）は、後方互換性を保ったバグ修正を取り込
   んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを
   修正する内部の変更のことを指します。

7. マイナーバージョン Y （x.Y.z `|` x > 0）は、後方互換性を保ちつつ機能性をパブ
   リック API に追加した場合、上げなければなりません（MUST）。また、いかなるパブ
   リック API も廃止予定としたのなら、上げなければなりません（MUST）。プライベー
   トコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです
   （MAY）。その際にパッチレベルの変更も含めてよいです（MAY）。マイナーバージョ
   ンを上げた際にはパッチバージョンは 0 にリセットしなければなりません（MUST）。

8. メジャーバージョン X （X.y.z `|` X > 0）は、パブリック API に対して後方互換性
   を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際マイ
   ナー、パッチレベルの変更も含めてよいです（MAY）。メジャーバージョンを上げた際
   にはパッチ、マイナーバージョンは 0 にリセットしなければなりません（MUST）。

9. プレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られ
   た識別子を追加することで表現してもよいです（MAY）。識別子は必ず ASCII 英数字
   とハイフン[0-9A-Za-z-]でなければなりません（MUST）。識別子は空であってはなり
   ません（MUST NOT）。数値の識別子はゼロからは始めてはなりません（MUST NOT）。
   プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリ
   リースバージョンは、不安定であり、関連する通常バージョンが示す要件と互換性を
   満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
   1.0.0-x.7.z.92。

10. ビルドメタデータはパッチもしくはプレリリースバージョンの直後にプラス記号とド
    ットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必
    ず ASCII 英数字とハイフン[0-9A-Za-z-]でなければなりません（MUST）。識別子は
    空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメ
    タデータは無視されるべきです（SHOULD）。つまり、2 つのビルドメタデータだけが
    違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001,
    1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。

11. バージョン同士をどのように比較するのかは優先度によって決まります。優先度はメ
    ジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度
    に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各
    識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャ
    ー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 <
    2.1.0 < 2.1.1。 メジャー、マイナー、パッチが同じ場合、プレリリースバージョン
    を持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha <
    1.0.0。 同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度
    の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較
    し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較
    され、文字列やハイフンを含む識別子は ASCII ソート順に辞書的に比較されます。
    数値的な識別子は常に非数値的な識別子よりも低い優先度です。もし先行する識別子
    が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが
    高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
    1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。

## なぜセマンティック バージョニングを使用するのか？

このアイデアは新しいものでもなければ、革新的なものでもありません。実際、みなさん
も似たような取り組みを既におこなっているかもしれません。問題は『似ている』のでは
不十分だということです。正式な仕様書による取り決めがなければ、バージョンナンバー
は依存性の管理において基本的には無意味です。上記のアイデアに対して名前と正確な定
義を与えることよって、あなたの開発するソフトウェアにおいて、あなたの意図がユーザ
ーに対して伝わりやすくなることでしょう。一度、これらの意図を正確にしてしまえば、
柔軟な（しかし、柔軟すぎてはいけない）依存性の仕様を作ることができます。

単純な例として、セマンティック バージョニングがどのように依存性地獄を過去のもの
とするかについて説明します。『Firetruck』と呼ばれるライブラリについて考えてみま
しょう。それはセマンティック バージョニングされた『Ladder』というパッケージを必
要とします。Firetruck を作成した時、Ladder はバージョン 3.1.0 でした。Firetruck
は、バージョン 3.1.0 時に導入されたいくつかの機能を使用しているので、Ladder が
3.1.0 以上 4.0.0 未満の範囲で安全に依存性を指定できます。Ladder のバージョン
3.1.1 と 3.2.0 が利用可能になった時、それらをパッケージ管理に取り込んでリリース
することができ、それらが既存の依存するソフトウェアと互換性があるということは明確
です。

賢明な開発者であれば、もちろんパッケージがアップグレードされたのならその機能を使
ってみたいと思うはずでしょう。しかし、この現実は混沌としていて、我々ができること
といったら、慎重になることくらいです。セマンティック バージョニングを実践するこ
とで、新しい依存パッケージを巻き込むことなく、まともな方法でリリース、アップグレ
ードすることができ、手間と時間を節約してくれることでしょう。

もし全面的に同意できると感じたのなら、セマンティック バージョニングを実践してい
ることを宣言し、ルールを守って下さい。それからあなたの README からこの Web サイ
トにリンクしてください、そうすれば、他の人がこのルールを知り、役立てることができ
るでしょう。

## FAQ

### 0.y.z のような初期の開発フェーズにおけるバージョンの取り扱いはどのようにすべきでしょうか？

一番簡単な方法は 0.1.0 からで開発版をリリースし、その後のリリースのたびにマイナ
ーバージョンを上げていけばよいでしょう。

### 1.0.0 のリリースはいつすべきでしょうか？

もし既にプロダクション用途であなたのソフトウェアが利用されているのなら、それは
1.0.0 であるべきでしょう。またもし安定した API を持ち、それに依存しているユーザ
ーが複数いるのなら、それは 1.0.0 であるべきでしょう。もし後方互換性について多大
な心配をしているのなら、それは 1.0.0 であるべきでしょう。

### 高速開発や高速イテレーションに悪影響を与えませんか？

メジャーバージョンがゼロの場合、それは高速開発を意味しています。もし、毎日 API
を変更しているのなら、0.y.z のバージョンのままにすべきか、開発ブランチとして切り
分け、次のメジャーバージョンアップのために開発すべきです。

### パブリック API に対して後方互換性を保たない、ほんの些細な変更があった際もメジャーバージョンアップをしなければならないのなら、42.0.0 のようなバージョンにすぐになってしまわないですか？

これは責任ある開発と深い洞察のある質問です。多くの依存されているコードを持つソフ
トウェアにおいて、非互換な変更を気軽に取り込むべきではありません。アップグレード
する度にかかるコストは無視できないものでしょう。非互換な変更をリリースするために
メジャーバージョンを上げることは、変更における悪影響を思い知ることになるでしょう
。加えて、コスト対効果を評価して判断すべきでしょう。

### すべてのパブリック API に関してドキュメントを書くのは重労働です。

ユーザーに使用されることを前提としたソフトウェアに適切なドキュメントを用意するこ
とはプロフェッショナルな開発者としての当然の責任です。ソフトウェアの複雑性を管理
することはプロジェクトをスムーズに続けていくために非常に重要なことで、もしあなた
のソフトウェアの使い方や、どのメソッドが安全に呼び出せるのかを誰も知らないのは望
ましい状況とは言えません。セマンティック バージョニングと適切に定義されたパブリ
ック API を宣言することは長期的に見ればメリットが大きいでしょう。

### もし誤って後方互換性のない変更をマイナーバージョンとしてリリースした場合、どうすればよいでしょうか？

セマンティック バージョニングの仕様に違反したのならすぐに問題を修正してください
。つまり後方互換性を復元し、新しくマイナーバージョンをリリースして下さい。このよ
うな状況下においてもリリースされたバージョンナンバーを修正してはなりません。適切
な対応が完了したのなら、次は違反したバージョンを記録し、それをユーザーに知らせま
しょう。

### もし、パブリック API の変更なしに自分のパッケージの依存性をアップデートしてしまったら、どうすべきでしょうか？

それ自体はパブリック API に影響しませんので安心してください。パッケージとして明
らかに同じ依存性を持つソフトウェアは自身の依存仕様を定義すべきですし、作成者はい
かなるコンフリクトも見逃さないでしょう。その変更がパッチレベルなのかマイナーレベ
ルなのかどうかは、パッケージの依存性をアップデートした理由がバグを修正するためか
新しい機能を実装するためかどうかに依存します。後者のケースの場合の明らかにそれは
マイナーレベルの変更でしょう。

### もしうっかりパブリック API をセマンティック バージョニングに対応していない形で変更したらどうなるでしょうか？（例：パッチリリースで主要なバグが発生した場合）

最善の判断をしてください。もしパブリック API の動作が変わることで大いに影響する
ユーザーがいる場合、厳密にはパッチリリースであると考慮されるかもしれませんが、そ
の後にメジャーバージョンをリリースするのがベストかもしれません。セマンティック
バージョニングはバージョンがどのように変更されるのかということを伝えるためのもの
であるということを注意して下さい。

### どのように非推奨機能を扱えばよいでしょうか？

既存機能を廃止予定にするのはソフトウェア開発においては普通の事であり、開発を進め
る上で頻繁に必要となります。パブリック API の一部を非推奨にしたい場合、2 つのこ
とをすべきです。第一にユーザーに知らせるためにドキュメントを更新して下さい。次に
非推奨機能を残したまま新しいマイナーバージョンをリリースして下さい。完全に非推奨
機能を削除しメジャーバージョンをリリースする前に、ユーザーがスムーズに新しい API
に移行できるように少なくとも 1 回のマイナーバージョン（非推奨機能を含んだ）をリ
リースして下さい。

### semver のバージョン文字列に限度はありますか？

いいえ、ありませんが良識ある判断をしてください。例えば 255 文字数のバージョン文
字列は過剰と言えるでしょうし、特定のシステムではそれ独自の文字列の限界値があるこ
とでしょう。

## 著者について

セマンティック バージョニング仕様書の著者
は[Tom Preston-Werner](http://tom.preston-werner.com/)氏です。彼は Gravatars の
考案者であり、GitHub の共同創設者でもあります。

もしフィードバックがある場合は
、[GitHub 上で issue を立てて下さい](https://github.com/mojombo/semver/issues)。

## ライセンス

[Creative Commons - CC BY 3.0](http://creativecommons.org/licenses/by/3.0/)
