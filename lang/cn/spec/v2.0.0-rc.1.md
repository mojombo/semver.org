---
layout: chinese
title: 语义化的版本控制 2.0.0-rc.1
---

语义化的版本控制 2.0.0-rc.1
===================================

在软件管理世界里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，引入的程序包越多，你就越有可能在不久的将来发现自己深陷绝望之中。

在多依赖的系统中发布新版本程序包很快成为噩梦。如果依赖关系过紧密，可能面临版本控制被锁死的风险（必须对每一个依赖程序包改版才能完成某次升级）。而如果依赖关系过于松散，又无法避免版本混乱（`产生超过合理值的版本数`）。当你项目的进展由于版本控制被锁死和/或版本混乱变得不那么简便和可靠，也就意味着你正处于依赖地狱之中。

为了解决这个问题，我提议通过一些规则和约束来表述版本号如何命名及何时更新。要使此系统正常运作，你首先需要声明一个公共应用程序接口（以下简称API）。可以`以文档形式或代码形式实施`。需要注意的是，这个API必须是清晰和明确的。一旦公共API确定下来，你将通过版本号增量来描述版本修改。形如X.Y.Z（主版本号.副版本号.补丁号）这样的版本格式。通过增加补丁号来表示不影响API的错误修复，增加副版本号来表示兼容现有API的扩展/修改，而增加主版本号则表示不兼容现有API的修改。

我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式 包含了相邻版本间的`底层`代码和修改部分的信息。


语义化版本控制说明（SemVer）
------------------------------------------

文档中出现的“*必须*”，“*禁止*”，“*要求*”，“*应该*”，“*不该*”，“*可能*”，“*可能不*”，“*建议*”，“*也许*”，和“*可选*”按RFC 2119规范解读。

1. 使用语义化版本控制的软件*必须* 声明公共API。该API可以在代码中声明也可以固化为文档。无论何种形式，API`应该`是明确而全面的。

1. 标准的版本号*必须*采用X.Y.Z的格式，其中X，Y，和Z为非负的整数。X是主版本号，Y是副版本号，而Z为补丁号。每个元素*必须*
取数值1为增量。例如：1.9.1->1.10.0->1.11.0。

1. 标记版本号的软件包发布后，*禁止*改变该版本软件包的内容。任何修改都必须以新版本发布。

1. 主版本号为0（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共API不应该被视为稳定版。

1. 1.0.0版本用于`界定`公共API的形成。这一版本之后所有的版本号更新都基于公共API及其修改。

1. 补丁号Z（x.y.Z | x>0）*必须*增加，仅在兼容原有接口的错误修复被引入时。错误修复指的是对不正确反应修复而进行的`内部修改`。

1. 副版本号Y （x.Y.z | x>0）*必须*增加，如果新的、兼容原有接口的功能被引入公共API；或者任何公共API被标记为弃用。副版本号*可能*增加，如果大量新功能或者改进被通过私有代码引入。这一过程中*可能*包含补丁级别的改变。当副版本号增加时补丁号必须置零。

1. 主版本号X （X.y.z | X>0）*必须*增加，如果任何不兼容原有接口的改变被引入到公共API，这一过程中可能包含副版本级别和补丁级别的改变。当主版本号增加时补丁号和副版本号*必须*置零。

1. 预发布版本*可以*通过紧跟在补丁号后的一个破折号和一系列点号分隔的标识符来修饰。这些标识符*必须*由ASCII码和破则号[0-9A-Za-z-]组成。预发布版本`满足需求`但优先级低于相关联的标准版本。例如： 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。

1. 构建版本*可以*通过紧跟在补丁号或者预发布本本号后的一个加号和一系列点号分隔的标识符来修饰。这些标识符*必须*由ASCII码和破则号[0-9A-Za-z-]组成。构建版本`满足需求`且优先级高于相关联的标准版本。例如：1.0.0+build, 1.3.7+build.11.e0f985a。

